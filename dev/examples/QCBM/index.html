<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum Circuit Born Machine · Tutorial|Yao</title><link rel="canonical" href="https://tutorials.yaoquantum.org/examples/QCBM/index.html"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/main.css" rel="stylesheet" type="text/css"/><link href="https://yaoquantum.org/assets/main.css" rel="stylesheet" type="text/css"/><link href="http://yaoquantum.org/favicon.ico" rel="icon" type="image/x-icon"/><link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="top" class="navbar-wrapper">
<nav class="navbar fixed-top navbar-expand-lg navbar-dark">
    <a class="navbar-brand" href="https://yaoquantum.org">
        <img src="https://yaoquantum.org/assets/images/logo-light.png">
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item active">
          <a class="nav-link" href="https://yaoquantum.org/tutorials">Tutorial<span class="sr-only">(current)</span></a>
        </li>

        <li class="nav-item">
            <a class="nav-link" href="https://docs.yaoquantum.org/">Documentation</a>
        </li>

        <li class="nav-item">
            <a class="nav-link" href="https://yaoquantum.org/benchmark">Benchmark</a>
        </li>

        <li class="nav-item">
            <a class="nav-link" href="https://github.com/QuantumBFS/Yao.jl">GitHub</a>
        </li>
      </ul>
    </div>
</nav>
</div>
<div class="documenter-wrapper" id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Tutorial|Yao</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../GHZ/">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="tocitem" href="../QFT/">Quantum Fourier Transformation and Phase Estimation</a></li><li class="is-active"><a class="tocitem" href>Quantum Circuit Born Machine</a><ul class="internal"><li><a class="tocitem" href="#Training-Target-1"><span>Training Target</span></a></li><li><a class="tocitem" href="#Create-the-Circuit-1"><span>Create the Circuit</span></a></li><li><a class="tocitem" href="#Rotation-Layer-1"><span>Rotation Layer</span></a></li><li><a class="tocitem" href="#Entangler-1"><span>Entangler</span></a></li><li><a class="tocitem" href="#MMD-Loss-and-Gradients-1"><span>MMD Loss &amp; Gradients</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Quantum Circuit Born Machine</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quantum Circuit Born Machine</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuantumBFS/tutorials/blob/master/src/examples/QCBM.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="qcbm-1"><a class="docs-heading-anchor" href="#qcbm-1">Quantum Circuit Born Machine</a><a class="docs-heading-anchor-permalink" href="#qcbm-1" title="Permalink"></a></h1><p>Yao is designed with variational quantum circuits in mind, and this tutorial will introduce how to use Yao for this kind of task by implementing a quantum circuit born machine described in <a href="https://arxiv.org/abs/1804.04168">Jin-Guo Liu, Lei Wang (2018)</a></p><p>let&#39;s use the package first</p><pre><code class="language-julia">using Yao, LinearAlgebra</code></pre><h2 id="Training-Target-1"><a class="docs-heading-anchor" href="#Training-Target-1">Training Target</a><a class="docs-heading-anchor-permalink" href="#Training-Target-1" title="Permalink"></a></h2><p>In this tutorial, we will ask the variational circuit to learn the most basic distribution: a guassian distribution. It is defined as follows:</p><div>\[f(x \left| \mu, \sigma^2\right) = \frac{1}{\sqrt{2\pi\sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}\]</div><p>We implement it as <code>gaussian_pdf</code>:</p><pre><code class="language-julia">function gaussian_pdf(x, μ::Real, σ::Real)
    pl = @. 1 / sqrt(2pi * σ^2) * exp(-(x - μ)^2 / (2 * σ^2))
    pl / sum(pl)
end
pg = gaussian_pdf(1:1&lt;&lt;6, 1&lt;&lt;5-0.5, 1&lt;&lt;4);</code></pre><p>We can plot the distribution, it looks like</p><p><img src="../../assets/figures/QCBM_1.svg" alt="Gaussian Distribution"/></p><h2 id="Create-the-Circuit-1"><a class="docs-heading-anchor" href="#Create-the-Circuit-1">Create the Circuit</a><a class="docs-heading-anchor-permalink" href="#Create-the-Circuit-1" title="Permalink"></a></h2><p>A quantum circuit born machine looks like the following:</p><p><img src="../../assets/figures/differentiable.png" alt="differentiable ciruit"/></p><p>It is composited by two different layers: <strong>rotation layer</strong> and <strong>entangler layer</strong>.</p><h2 id="Rotation-Layer-1"><a class="docs-heading-anchor" href="#Rotation-Layer-1">Rotation Layer</a><a class="docs-heading-anchor-permalink" href="#Rotation-Layer-1" title="Permalink"></a></h2><p>Arbitrary rotation is built with <strong>Rotation Gate</strong> on <strong>Z, X, Z</strong> axis with parameters.</p><div>\[Rz(\theta) \cdot Rx(\theta) \cdot Rz(\theta)\]</div><p>Since our input will be a <span>$|0\dots 0\rangle$</span> state. The first layer of arbitrary rotation can just use <span>$Rx(\theta) \cdot Rz(\theta)$</span> and the last layer of arbitrary rotation could just use <span>$Rz(\theta)\cdot Rx(\theta)$</span></p><p>In <strong>幺</strong>, every Hilbert operator is a <strong>block</strong> type, this ncludes all <strong>quantum gates</strong> and <strong>quantum oracles</strong>. In general, operators appears in a quantum circuit can be divided into <strong>Composite Blocks</strong> and <strong>Primitive Blocks</strong>.</p><p>We follow the low abstraction principle and thus each block represents a certain approach of calculation. The simplest <strong>Composite Block</strong> is a <strong>Chain Block</strong>, which chains other blocks (oracles) with the same number of qubits together. It is just a simple mathematical composition of operators with same size. e.g.</p><div>\[\text{chain(X, Y, Z)} \iff X \cdot Y \cdot Z\]</div><p>We can construct an arbitrary rotation block by chain <span>$Rz$</span>, <span>$Rx$</span>, <span>$Rz$</span> together.</p><pre><code class="language-julia">chain(Rz(0.0), Rx(0.0), Rz(0.0))</code></pre><pre><code class="language-none">nqubits: 1
chain
├─ rot(Z gate, 0.0)
├─ rot(X gate, 0.0)
└─ rot(Z gate, 0.0)</code></pre><p><a href="examples/@ref"><code>Rx</code></a>, <a href="examples/@ref"><code>Rz</code></a> will construct new rotation gate, which are just shorthands for <code>rot(X, 0.0)</code>, etc.</p><p>Then let&#39;s chain them up</p><pre><code class="language-julia">layer(nbit::Int, x::Symbol) = layer(nbit, Val(x))
layer(nbit::Int, ::Val{:first}) = chain(nbit, put(i=&gt;chain(Rx(0), Rz(0))) for i = 1:nbit);</code></pre><p>We do not need to feed the first <code>n</code> parameter into <code>put</code> here. All factory methods can be <strong>lazy</strong> evaluate <strong>the first arguements</strong>, which is the number of qubits. It will return a lambda function that requires a single interger input. The instance of desired block will only be constructed until all the information is filled. When you filled all the information in somewhere of the declaration, 幺 will be able to infer the others. We will now define the rest of rotation layers</p><pre><code class="language-julia">layer(nbit::Int, ::Val{:last}) = chain(nbit, put(i=&gt;chain(Rz(0), Rx(0))) for i = 1:nbit)
layer(nbit::Int, ::Val{:mid}) = chain(nbit, put(i=&gt;chain(Rz(0), Rx(0), Rz(0))) for i = 1:nbit);</code></pre><h2 id="Entangler-1"><a class="docs-heading-anchor" href="#Entangler-1">Entangler</a><a class="docs-heading-anchor-permalink" href="#Entangler-1" title="Permalink"></a></h2><p>Another component of quantum circuit born machine are several <strong>CNOT</strong> operators applied on different qubits.</p><pre><code class="language-julia">entangler(pairs) = chain(control(ctrl, target=&gt;X) for (ctrl, target) in pairs);</code></pre><p>We can then define such a born machine</p><pre><code class="language-julia">function build_circuit(n, nlayers, pairs)
    circuit = chain(n)
    push!(circuit, layer(n, :first))
    for i in 2:nlayers
        push!(circuit, cache(entangler(pairs)))
        push!(circuit, layer(n, :mid))
    end
    push!(circuit, cache(entangler(pairs)))
    push!(circuit, layer(n, :last))
    return circuit
end</code></pre><pre><code class="language-none">build_circuit (generic function with 1 method)</code></pre><p>We use the method <code>cache</code> here to tag the entangler block that it should be cached after its first run, because it is actually a constant oracle. Let&#39;s see what will be constructed</p><pre><code class="language-julia">build_circuit(4, 1, [1=&gt;2, 2=&gt;3, 3=&gt;4])</code></pre><pre><code class="language-none">nqubits: 4
chain
├─ chain
│  ├─ put on (1)
│  │  └─ chain
│  │     ├─ rot(X gate, 0.0)
│  │     └─ rot(Z gate, 0.0)
│  ├─ put on (2)
│  │  └─ chain
│  │     ├─ rot(X gate, 0.0)
│  │     └─ rot(Z gate, 0.0)
│  ├─ put on (3)
│  │  └─ chain
│  │     ├─ rot(X gate, 0.0)
│  │     └─ rot(Z gate, 0.0)
│  └─ put on (4)
│     └─ chain
│        ├─ rot(X gate, 0.0)
│        └─ rot(Z gate, 0.0)
├─ [cached] chain
│     ├─ control(1)
│     │  └─ (2,) X gate
│     ├─ control(2)
│     │  └─ (3,) X gate
│     └─ control(3)
│        └─ (4,) X gate
└─ chain
   ├─ put on (1)
   │  └─ chain
   │     ├─ rot(Z gate, 0.0)
   │     └─ rot(X gate, 0.0)
   ├─ put on (2)
   │  └─ chain
   │     ├─ rot(Z gate, 0.0)
   │     └─ rot(X gate, 0.0)
   ├─ put on (3)
   │  └─ chain
   │     ├─ rot(Z gate, 0.0)
   │     └─ rot(X gate, 0.0)
   └─ put on (4)
      └─ chain
         ├─ rot(Z gate, 0.0)
         └─ rot(X gate, 0.0)</code></pre><h2 id="MMD-Loss-and-Gradients-1"><a class="docs-heading-anchor" href="#MMD-Loss-and-Gradients-1">MMD Loss &amp; Gradients</a><a class="docs-heading-anchor-permalink" href="#MMD-Loss-and-Gradients-1" title="Permalink"></a></h2><p>The MMD loss is describe below:</p><div>\[\begin{aligned}
\mathcal{L} &amp;= \left| \sum_{x} p \theta(x) \phi(x) - \sum_{x} \pi(x) \phi(x) \right|^2\\
            &amp;= \langle K(x, y) \rangle_{x \sim p_{\theta}, y\sim p_{\theta}} - 2 \langle K(x, y) \rangle_{x\sim p_{\theta}, y\sim \pi} + \langle K(x, y) \rangle_{x\sim\pi, y\sim\pi}
\end{aligned}\]</div><p>We will use a squared exponential kernel here.</p><pre><code class="language-julia">struct RBFKernel
    σ::Float64
    m::Matrix{Float64}
end

function RBFKernel(σ::Float64, space)
    dx2 = (space .- space&#39;).^2
    return RBFKernel(σ, exp.(-1/2σ * dx2))
end

kexpect(κ::RBFKernel, x, y) = x&#39; * κ.m * y</code></pre><pre><code class="language-none">kexpect (generic function with 1 method)</code></pre><p>There are two different way to define the loss:</p><p>In simulation we can use the probability distribution of the state directly</p><pre><code class="language-julia">get_prob(qcbm) = probs(zero_state(nqubits(qcbm)) |&gt; qcbm)

function loss(κ, c, target)
    p = get_prob(c) - target
    return kexpect(κ, p, p)
end</code></pre><pre><code class="language-none">loss (generic function with 1 method)</code></pre><p>Or if you want to simulate the whole process with measurement (which is entirely physical), you should define the loss with measurement results, for convenience we directly use the simulated results as our loss</p><h3 id="Gradients-1"><a class="docs-heading-anchor" href="#Gradients-1">Gradients</a><a class="docs-heading-anchor-permalink" href="#Gradients-1" title="Permalink"></a></h3><p>the gradient of MMD loss is</p><div>\[\begin{aligned}
\frac{\partial \mathcal{L}}{\partial \theta^i_l} &amp;= \langle K(x, y) \rangle_{x\sim p_{\theta^+}, y\sim p_{\theta}} - \langle K(x, y) \rangle_{x\sim p_{\theta}^-, y\sim p_{\theta}}\\
&amp;- \langle K(x, y) \rangle _{x\sim p_{\theta^+}, y\sim\pi} + \langle K(x, y) \rangle_{x\sim p_{\theta^-}, y\sim\pi}
\end{aligned}\]</div><p>which can be implemented as</p><pre><code class="language-julia">function gradient(qcbm, κ, ptrain)
    n = nqubits(qcbm)
    prob = get_prob(qcbm)
    grad = zeros(Float64, nparameters(qcbm))

    count = 1
    for k in 1:2:length(qcbm), each_line in qcbm[k], gate in content(each_line)
        dispatch!(+, gate, π/2)
        prob_pos = probs(zero_state(n) |&gt; qcbm)

        dispatch!(-, gate, π)
        prob_neg = probs(zero_state(n) |&gt; qcbm)

        dispatch!(+, gate, π/2) # set back

        grad_pos = kexpect(κ, prob, prob_pos) - kexpect(κ, prob, prob_neg)
        grad_neg = kexpect(κ, ptrain, prob_pos) - kexpect(κ, ptrain, prob_neg)
        grad[count] = grad_pos - grad_neg
        count += 1
    end
    return grad
end</code></pre><pre><code class="language-none">gradient (generic function with 1 method)</code></pre><p>Now let&#39;s setup the training</p><pre><code class="language-julia">using Flux.Optimise
qcbm = build_circuit(6, 10, [1=&gt;2, 3=&gt;4, 5=&gt;6, 2=&gt;3, 4=&gt;5, 6=&gt;1])
dispatch!(qcbm, :random) # initialize the parameters

κ = RBFKernel(0.25, 0:2^6-1)
pg = gaussian_pdf(1:1&lt;&lt;6, 1&lt;&lt;5-0.5, 1&lt;&lt;4);
opt = ADAM()

function train(qcbm, κ, opt, target)
    history = Float64[]
    for _ in 1:100
        push!(history, loss(κ, qcbm, target))
        ps = parameters(qcbm)
        Optimise.update!(opt, ps, gradient(qcbm, κ, target))
        popdispatch!(qcbm, ps)
    end
    return history
end

history = train(qcbm, κ, opt, pg)
trained_pg = probs(zero_state(nqubits(qcbm)) |&gt; qcbm)
history</code></pre><pre><code class="language-none">100-element Array{Float64,1}:
 0.01639631048931224   
 0.015876459208370795  
 0.015373011094485816  
 0.014884975030985431  
 0.014410662626770314  
 0.013949050305265002  
 0.01349972133500174   
 0.013062649568481412  
 0.012637907800397736  
 0.012225071578230743  
 ⋮                     
 0.00029875542169632244
 0.0002762172226952762 
 0.000254924041639635  
 0.0002345606420192594 
 0.00021522951516679165
 0.0001969394077878699 
 0.0001796033444645813 
 0.00016374949434421474
 0.0001487161965798975</code></pre><p>And we have the history of training which is</p><pre><code class="language-julia">
using Plots
fig1 = plot(history; legend=nothing)
title!(&quot;training history&quot;)
xlabel!(&quot;steps&quot;); ylabel!(&quot;loss&quot;)</code></pre><p><img src="../../assets/figures/history.png" alt/></p><p>And let&#39;s check what we got</p><pre><code class="language-julia">
fig2 = plot(1:1&lt;&lt;6, trained_pg; label=&quot;trained&quot;)
plot!(fig2, 1:1&lt;&lt;6, pg; label=&quot;target&quot;)
title!(&quot;distribution&quot;)
xlabel!(&quot;x&quot;); ylabel!(&quot;p&quot;)</code></pre><p><img src="../../assets/figures/distribution.png" alt/></p><p>So within 50 steps, we got a pretty close estimation of our target distribution!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../QFT/">« Quantum Fourier Transformation and Phase Estimation</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 6 December 2019 08:03">Friday 6 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum Fourier Transformation and Phase Estimation · Tutorial|Yao</title><link rel="canonical" href="https://tutorials.yaoquantum.org/generated/examples/qft-phase-estimation/index.html"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/main.css" rel="stylesheet" type="text/css"/><link href="https://yaoquantum.org/assets/main.css" rel="stylesheet" type="text/css"/><link href="http://yaoquantum.org/favicon.ico" rel="icon" type="image/x-icon"/><link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="top" class="navbar-wrapper">
<nav class="navbar fixed-top navbar-expand-lg navbar-dark">
    <a class="navbar-brand" href="https://yaoquantum.org">
        <img src="https://yaoquantum.org/assets/images/logo-light.png">
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item active">
          <a class="nav-link" href="#">Tutorial<span class="sr-only">(current)</span></a>
        </li>

        <li class="nav-item">
            <a class="nav-link" href="https://docs.yaoquantum.org/dev">Documentation</a>
        </li>

        <li class="nav-item">
            <a class="nav-link" href="https://yaoquantum.org/benchmark">Benchmark</a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="http://yaoquantum.org/soc">SoC</a>
        </li>

        <li class="nav-item">
          <a class="nav-link" href="http://yaoquantum.org/research">Research</a>
        </li>

        <li class="nav-item">
            <a class="nav-link" href="https://github.com/QuantumBFS/Yao.jl">GitHub</a>
        </li>
      </ul>
    </div>
</nav>
</div>
<div class="documenter-wrapper" id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Tutorial|Yao</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../prepare-ghz-state/">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li class="is-active"><a class="tocitem" href>Quantum Fourier Transformation and Phase Estimation</a><ul class="internal"><li><a class="tocitem" href="#Quantum-Fourier-Transformation-1"><span>Quantum Fourier Transformation</span></a></li><li><a class="tocitem" href="#Wrap-QFT-to-an-external-block-1"><span>Wrap QFT to an external block</span></a></li><li><a class="tocitem" href="#Phase-Estimation-1"><span>Phase Estimation</span></a></li><li class="toplevel"><a class="tocitem" href="#using-LinearAlgebra-1"><span>using LinearAlgebra</span></a></li></ul></li><li><a class="tocitem" href="../quantum-circuit-born-machine/">Quantum Circuit Born Machine</a></li><li><a class="tocitem" href="../shor-9-code/">Shor&#39;s 9 qubit code</a></li><li><a class="tocitem" href="../variation-quantum-eigen-solver/">Variational Quantum Eigen Solver</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Quantum Fourier Transformation and Phase Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quantum Fourier Transformation and Phase Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuantumBFS/tutorials/blob/master/examples/qft-phase-estimation/main.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p><a href="https://mybinder.org/v2/gh/QuantumBFS/tutorials/gh-pages?filepath=dev/generated/examples/qft-phase-estimation.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/QuantumBFS/tutorials/blob/gh-pages/dev/generated/examples/qft-phase-estimation.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><h1 id="Quantum-Fourier-Transformation-and-Phase-Estimation-1"><a class="docs-heading-anchor" href="#Quantum-Fourier-Transformation-and-Phase-Estimation-1">Quantum Fourier Transformation and Phase Estimation</a><a class="docs-heading-anchor-permalink" href="#Quantum-Fourier-Transformation-and-Phase-Estimation-1" title="Permalink"></a></h1><p>Let&#39;s use Yao first</p><pre><code class="language-julia">using Yao</code></pre><h2 id="Quantum-Fourier-Transformation-1"><a class="docs-heading-anchor" href="#Quantum-Fourier-Transformation-1">Quantum Fourier Transformation</a><a class="docs-heading-anchor-permalink" href="#Quantum-Fourier-Transformation-1" title="Permalink"></a></h2><p>The Quantum Fourier Transformation (QFT) circuit is to repeat two kinds of blocks repeatly:</p><p><img src="assets/qft.png" alt="qft-circuit"/></p><p>The basic building block control phase shift gate is defined as</p><div>\[R(k)=\begin{bmatrix}
1 &amp; 0\\
0 &amp; \exp\left(\frac{2\pi i}{2^k}\right)
\end{bmatrix}\]</div><p>Let&#39;s define block <code>A</code> and block <code>B</code>, block <code>A</code> is actually a control block.</p><pre><code class="language-julia">A(i, j) = control(i, j=&gt;shift(2π/(1&lt;&lt;(i-j+1))))</code></pre><pre><code class="language-none">A (generic function with 1 method)</code></pre><p>Once you construct the blockl you can inspect its matrix using <code>mat</code> function. Let&#39;s construct the circuit in dash box A, and see the matrix of <span>$R_4$</span> gate.</p><pre><code class="language-julia">R4 = A(4, 1)</code></pre><pre><code class="language-none">(n -&gt; control(n, 4, 1 =&gt; shift(0.39269908169872414)))</code></pre><p>If you have read about <a href="../prepare-ghz-state/#example-ghz-1">preparing GHZ state</a>, you probably know that in Yao, we could just leave the number of qubits, and it will be evaluated when possible.</p><pre><code class="language-julia">R4(5)</code></pre><pre><code class="language-none">nqubits: 5
control(4)
└─ (1,) shift(0.39269908169872414)</code></pre><p>its matrix will be</p><pre><code class="language-julia">mat(R4(5))</code></pre><pre><code class="language-none">32×32 LinearAlgebra.Diagonal{Complex{Float64},Array{Complex{Float64},1}}:
 1.0+0.0im      ⋅          ⋅          ⋅      …      ⋅              ⋅         
     ⋅      1.0+0.0im      ⋅          ⋅             ⋅              ⋅         
     ⋅          ⋅      1.0+0.0im      ⋅             ⋅              ⋅         
     ⋅          ⋅          ⋅      1.0+0.0im         ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅             ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅      …      ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅             ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅             ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅             ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅             ⋅              ⋅         
    ⋮                                        ⋱     ⋮                         
     ⋅          ⋅          ⋅          ⋅             ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅             ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅      …      ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅             ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅             ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅             ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅             ⋅              ⋅         
     ⋅          ⋅          ⋅          ⋅      …  1.0+0.0im          ⋅         
     ⋅          ⋅          ⋅          ⋅             ⋅      0.92388+0.382683im</code></pre><p>Then we repeat this control block over and over on different qubits, and put a Hadamard gate to <code>i</code>th qubit to construct <code>i</code>-th <code>B</code> block.</p><pre><code class="language-julia">B(n, k) = chain(n, j==k ? put(k=&gt;H) : A(j, k) for j in k:n)</code></pre><pre><code class="language-none">B (generic function with 1 method)</code></pre><p>We need to input the total number of qubits <code>n</code> here because we have to iterate through from <code>k</code>-th location to the last.</p><p>Now, let&#39;s construct the circuit by chaining all the <code>B</code> blocks together</p><pre><code class="language-julia">qft(n) = chain(B(n, k) for k in 1:n)
qft(4)</code></pre><pre><code class="language-none">nqubits: 4
chain
├─ chain
│  ├─ put on (1)
│  │  └─ H gate
│  ├─ control(2)
│  │  └─ (1,) shift(1.5707963267948966)
│  ├─ control(3)
│  │  └─ (1,) shift(0.7853981633974483)
│  └─ control(4)
│     └─ (1,) shift(0.39269908169872414)
├─ chain
│  ├─ put on (2)
│  │  └─ H gate
│  ├─ control(3)
│  │  └─ (2,) shift(1.5707963267948966)
│  └─ control(4)
│     └─ (2,) shift(0.7853981633974483)
├─ chain
│  ├─ put on (3)
│  │  └─ H gate
│  └─ control(4)
│     └─ (3,) shift(1.5707963267948966)
└─ chain
   └─ put on (4)
      └─ H gate
</code></pre><h2 id="Wrap-QFT-to-an-external-block-1"><a class="docs-heading-anchor" href="#Wrap-QFT-to-an-external-block-1">Wrap QFT to an external block</a><a class="docs-heading-anchor-permalink" href="#Wrap-QFT-to-an-external-block-1" title="Permalink"></a></h2><p>In most cases, <code>function</code>s are enough to wrap quantum circuits, like <code>A</code> and <code>B</code> we defined above, but sometimes, we need to dispatch specialized methods on certain kinds of quantum circuit, or we want to define an external block to export, thus, it&#39;s useful to be able to wrap circuit to custom blocks.</p><p>First, we define a new type as subtype of <code>PrimitiveBlock</code> since we are not going to use the subblocks of <code>QFT</code>, if you need to use its subblocks, it&#39;d be better to define it under <code>CompositeBlock</code>.</p><pre><code class="language-julia">struct QFT{N} &lt;: PrimitiveBlock{N} end
QFT(n::Int) = QFT{n}()</code></pre><pre><code class="language-none">Main.ex-index.QFT</code></pre><p>Now, let&#39;s define its circuit</p><pre><code class="language-julia">circuit(::QFT{N}) where N = qft(N)</code></pre><pre><code class="language-none">circuit (generic function with 1 method)</code></pre><p>And forward <code>mat</code> to its circuit&#39;s matrix</p><pre><code class="language-julia">YaoBlocks.mat(::Type{T}, x::QFT) where T = mat(T, circuit(x))</code></pre><p>You may notice, it is a little ugly to print <code>QFT</code> at the moment, this is because we print the type summary by default, you can define your own printing by overloading <code>print_block</code></p><pre><code class="language-julia">YaoBlocks.print_block(io::IO, x::QFT{N}) where N = print(io, &quot;QFT($N)&quot;)</code></pre><p>Since it is possible to use FFT to simulate the results of QFT (like cheating), we could define our custom <code>apply!</code> method:</p><pre><code class="language-julia">using FFTW, LinearAlgebra

function YaoBlocks.apply!(r::ArrayReg, x::QFT)
    α = sqrt(length(statevec(r)))
    invorder!(r)
    lmul!(α, ifft!(statevec(r)))
    return r
end</code></pre><p>Now let&#39;s check if our <code>apply!</code> method is correct:</p><pre><code class="language-julia">r = rand_state(5)
r1 = r |&gt; copy |&gt; QFT(5)
r2 = r |&gt; copy |&gt; circuit(QFT(5))
r1 ≈ r2</code></pre><pre><code class="language-none">true</code></pre><p>We can get iQFT (inverse QFT) directly by calling <code>adjoint</code></p><pre><code class="language-julia">QFT(5)&#39;</code></pre><pre><code class="language-none"> [†]QFT(5)</code></pre><p>QFT and iQFT are different from FFT and IFFT in three ways,</p><ol><li>they are different by a factor of <span>$\sqrt{2^n}$</span> with <span>$n$</span> the number of qubits.</li><li>the <a href="https://quantumbfs.github.io/BitBasis.jl/stable/tutorial/#Conventions-1">bit numbering</a> will exchange after applying QFT or iQFT.</li><li>due to the convention, QFT is more related to IFFT rather than FFT.</li></ol><h2 id="Phase-Estimation-1"><a class="docs-heading-anchor" href="#Phase-Estimation-1">Phase Estimation</a><a class="docs-heading-anchor-permalink" href="#Phase-Estimation-1" title="Permalink"></a></h2><p>Since we have QFT and iQFT blocks we can then use them to realize phase estimation circuit, what we want to realize is the following circuit:</p><p><img src="assets/phaseest.png" alt="phase estimation"/></p><pre><code class="language-julia">using Yao</code></pre><p>First we call Hadamard gates repeatly on first <code>n</code> qubits.</p><pre><code class="language-julia">Hadamards(n) = repeat(H, 1:n)</code></pre><pre><code class="language-none">Hadamards (generic function with 1 method)</code></pre><p>Then in dashed box <code>B</code>, we have controlled unitaries:</p><pre><code class="language-julia">ControlU(n, m, U) = chain(n+m, control(k, n+1:n+m=&gt;matblock(U^(2^(k-1)))) for k in 1:n)</code></pre><pre><code class="language-none">ControlU (generic function with 1 method)</code></pre><p>each of them is a <code>U</code> of power <span>$2^(k-1)$</span>.</p><p>Since we will only apply the qft and Hadamard on first <code>n</code> qubits, we could use <code>Concentrator</code>, which creates a context of a sub-scope of the qubits.</p><pre><code class="language-julia">PE(n, m, U) =
    chain(n+m, # total number of the qubits
        concentrate(Hadamards(n), 1:n), # apply H in local scope
        ControlU(n, m, U),
        concentrate(QFT(n)&#39;, 1:n))</code></pre><pre><code class="language-none">PE (generic function with 1 method)</code></pre><p>we use the first <code>n</code> qubits as the output space to store phase <span>$ϕ$</span>, and the other <code>m</code> qubits as the input state which corresponds to an eigenvector of oracle matrix <code>U</code>.</p><p>The concentrator here uses <code>focus!</code> and <code>relax!</code> to manage a local scope of quantum circuit, and only active the first <code>n</code> qubits while applying the block inside the concentrator context, and the scope will be <code>relax!</code>ed back, after the context. This is equivalent to manually <code>focus!</code> then <code>relax!</code></p><p>fullly activated</p><pre><code class="language-julia">r = rand_state(5)</code></pre><pre><code class="language-none">ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 5/5</code></pre><p>first 3 qubits activated</p><pre><code class="language-julia">focus!(r, 1:3)</code></pre><pre><code class="language-none">ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 3/5</code></pre><p>relax back to the original</p><pre><code class="language-julia">relax!(r, 1:3)</code></pre><pre><code class="language-none">ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 5/5</code></pre><p>In this way, we will be able to apply small operator directly on the subset of the qubits.</p><p>Details about the algorithm can be found here: <a href="ttps://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm">Quantum Phase Estimation Algorithm</a></p><p>Now let&#39;s check the results of our phase estimation.</p><p>First we need to set up a unitary with known phase, we set the phase to be 0.75, which is <code>0.75 * 2^3 == 6 == 0b110</code> .</p><h1 id="using-LinearAlgebra-1"><a class="docs-heading-anchor" href="#using-LinearAlgebra-1">using LinearAlgebra</a><a class="docs-heading-anchor-permalink" href="#using-LinearAlgebra-1" title="Permalink"></a></h1><pre><code class="language-julia">N, M = 3, 5
P = eigen(rand_unitary(1&lt;&lt;M)).vectors
θ = Int(0b110) / 1&lt;&lt;N
phases = rand(1&lt;&lt;M)
phases[0b010+1] = θ
U = P * Diagonal(exp.(2π * im * phases)) * P&#39;</code></pre><pre><code class="language-none">32×32 Array{Complex{Float64},2}:
 -0.0443373+0.206171im    …     0.054604-0.0277812im 
 0.00660508-0.17278im          -0.055702-0.118968im  
   0.399783+0.0832168im        0.0128624+0.0023319im 
  0.0293409+0.124869im         0.0876665+0.0429379im 
 -0.0449944+0.0573268im         0.124092-0.0955731im 
  0.0401794+0.195732im    …     0.208405+0.195713im  
  -0.104237-0.208707im         0.0205073-0.096845im  
 -0.0998266-0.0256205im        0.0755142+0.00968148im
 -0.0672826-0.0778827im      -0.00239238+0.118526im  
  -0.219813-0.127769im          0.280457+0.0279633im 
           ⋮              ⋱                          
  0.0510776-0.00425791im       -0.094013-0.0704271im 
  -0.109521+0.0865802im       0.00562626+0.0400641im 
   -0.12761+0.10444im     …    -0.136786-0.207038im  
   0.145855+0.0558595im         0.066577-0.0127861im 
   0.031943+0.0387091im        0.0241104+0.0954841im 
  0.0614047-0.159578im          0.305752-0.0897441im 
 -0.0425423+0.0878467im       -0.0333321+0.165022im  
  0.0839277-0.0415432im   …     0.166426-0.0340179im 
   0.202148-0.0831567im       -0.0448763+0.0152755im </code></pre><p>and then generate the state <span>$ψ$</span></p><pre><code class="language-julia">psi = P[:, 3]</code></pre><pre><code class="language-none">32-element Array{Complex{Float64},1}:
  -0.11236847321715963 - 0.08416109495852042im 
   0.20082264365877386 - 0.18700043190836582im 
  0.017822038935760634 - 0.17133083553980943im 
   0.06940521471382104 + 0.24926575425687764im 
   0.21716166511207427 + 0.05075537199232105im 
 -0.025091890132619595 + 0.008408667227488563im
   -0.1577570658204247 + 0.23475670668839368im 
   -0.2151924238335243 + 0.15200048274867087im 
 -0.010619901110937632 - 0.02706035479406986im 
  -0.02841623721320711 - 0.014373500731814908im
                       ⋮                       
    0.2434405925719596 - 0.09083206453829996im 
  -0.08764635319787861 + 0.1914020248341267im  
  -0.03996405936310076 - 0.04824322285858397im 
 -0.045389510625319325 + 0.06532693727617661im 
   0.11687323326892178 - 0.035577265868132736im
  -0.24975268144402632 + 0.05652650348612215im 
   0.04657697519046229 - 0.07268276473664756im 
   0.18244029323468725 + 0.12986691387327923im 
   0.13614859893878778 + 0.11167344083867826im </code></pre><p>In the phase estimation process, we will feed the state to circuit and measure the first <code>n</code> qubits processed by iQFT.</p><pre><code class="language-julia">r = join(ArrayReg(psi), zero_state(N))
r |&gt; PE(N, M, U)</code></pre><pre><code class="language-none">ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 8/8</code></pre><p>Since our phase can be represented by 3 qubits precisely, we only need to measure once</p><pre><code class="language-julia">results = measure(r, 1:N; nshots=1)</code></pre><pre><code class="language-none">1-element Array{BitBasis.BitStr{3,Int64},1}:
 011 ₍₂₎</code></pre><p>Recall that our QFT&#39;s bit numbering is reversed, let&#39;s reverse it back</p><pre><code class="language-julia">using BitBasis
estimated_phase = bfloat(results[]; nbits=N)</code></pre><pre><code class="language-none">0.75</code></pre><p>the phase is exactly <code>0.75</code>!</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../prepare-ghz-state/">« Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a><a class="docs-footer-nextpage" href="../quantum-circuit-born-machine/">Quantum Circuit Born Machine »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 7 December 2019 08:21">Saturday 7 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
